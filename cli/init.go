package cli

import (
	"encoding/csv"
	"fmt"
	"net/http"
	"os"
	"time"

	"github.com/Zenithar/exploitdb/models"
	"github.com/blevesearch/bleve"
	"github.com/spf13/cobra"
)

var initialFeed = "https://raw.githubusercontent.com/offensive-security/exploit-database/master/files.csv"

// BuildInitCommand returns a command for initialising vulnerability databases from the NVD CPE feeds.
func BuildInitCommand() *cobra.Command {
	var dbFile string
	var force bool

	cmd := &cobra.Command{
		Use:   "init",
		Short: "Initializes the database with the Exploit Database CSV file.",
		Run: func(cmd *cobra.Command, args []string) {

			if force == true {
				fmt.Printf("Force removing %s\n", dbFile)
				os.RemoveAll(dbFile)
			}

			fmt.Println("Initializing database. Downloading complete CSV file from github.")

			err := os.MkdirAll(defaultBaseDir(), 0777)
			check(err)

			index, err := bleve.Open(dbFile)
			if err == bleve.ErrorIndexPathDoesNotExist {
				mapping := bleve.NewIndexMapping()
				index, err = bleve.New(dbFile, mapping)
			}

			fmt.Printf("Processing %s ... ", initialFeed)
			resp, err := http.Get(initialFeed)
			check(err)

			reader := resp.Body
			defer reader.Close()

			lines, err := csv.NewReader(reader).ReadAll()
			total := len(lines)

			batch := index.NewBatch()
			count := 0
			for _, row := range lines {

				var result models.Exploit

				result.ID = row[0]
				result.File = row[1]
				result.Description = row[2]
				result.Date, _ = time.Parse("2006-01-02", row[3])
				result.Author = row[4]
				result.Platform = row[5]
				result.Type = row[6]
				result.Port = row[7]

				batch.Index(result.ID, result)
				count++

				if count%1000 == 0 {
					index.Batch(batch)
					batch = index.NewBatch()
				}

				if count%(total/10) == 0 {
					fmt.Printf("#")
				}
			}

			index.Batch(batch)

			fmt.Printf("finished processing %d entries\n", count)
		},
	}

	cmd.Flags().StringVarP(&dbFile, "db-file", "d", defaultDbFile(), "exploit db file to build")
	cmd.Flags().BoolVarP(&force, "force", "f", false, "overwrite existing exploit db")

	return cmd
}
